//-----------------------------------------------------------------------------
// File : asdxJobSystem.cpp
// Desc : JobSystem
// Copyright(c) Project Asura. All right reserved.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Inlcudes
//-----------------------------------------------------------------------------
#include <cassert>
#include <atomic>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <fnd/asdxJobSystem.h>
#include <fnd/asdxList.h>
#include <fnd/asdxQueue.h>
#include <fnd/asdxLogger.h>


namespace asdx {

//-----------------------------------------------------------------------------
// Forward Declarations.
//-----------------------------------------------------------------------------
class JobSyncPoint;
class JobQueue;
class JobSystem;

//-----------------------------------------------------------------------------
// Global Variables.
//-----------------------------------------------------------------------------
namespace {
JobSystem*  g_JobSystem = nullptr;
}//namespace


///////////////////////////////////////////////////////////////////////////////
// JobNode structure
///////////////////////////////////////////////////////////////////////////////
struct JobNode 
: public List<JobNode>::Node
, public Queue<JobNode>::Node
{
    Job             Job         = {};       //!< ジョブ情報.
    JobSyncPoint*   pSyncPoint  = nullptr;  //!< 同期点.

    void Run();
};

///////////////////////////////////////////////////////////////////////////////
// JobQueue class
///////////////////////////////////////////////////////////////////////////////
class JobQueue
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    JobQueue() = default;

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~JobQueue() = default;

    //-------------------------------------------------------------------------
    //! @brief      初期化処理を行います.
    //-------------------------------------------------------------------------
    void Init(uint8_t threadCount)
    {
        assert(threadCount <= std::thread::hardware_concurrency());

        m_ExitRequest = false;

        m_Threads.reserve(threadCount);
        for(auto i=0; i<threadCount; ++i)
        { m_Threads.emplace_back(std::thread(&JobQueue::Worker, this)); }
    }

    //-------------------------------------------------------------------------
    //! @brief      終了処理を行います.
    //-------------------------------------------------------------------------
    void Term()
    {
        // 終了要求フラグを立てる.
        {
            std::unique_lock<std::mutex> locker(m_Mutex);
            m_ExitRequest = true;
        }

        // 全部起こす.
        m_Condition.notify_all();

        // スレッド終了待ち.
        for(auto& thread : m_Threads)
        { thread.join(); }

        // ジョブ破棄.
        m_Queue.clear();

        // スレッド破棄.
        m_Threads.clear();
        m_Threads.shrink_to_fit();
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを登録します.
    //-------------------------------------------------------------------------
    void Push(JobNode* item)
    {
        assert(item != nullptr);

        // キューに追加.
        {
            std::unique_lock<std::mutex> locker(m_Mutex);
            m_Queue.push(item);
        }

        // 起こす.
        m_Condition.notify_one();
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブの完了を待機します
    //-------------------------------------------------------------------------
    void Wait()
    {
        std::unique_lock<std::mutex> locker(m_Mutex);
        if (m_Queue.empty() || m_ExitRequest)
        { return; }

        m_Condition.wait(locker);
    }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    bool                        m_ExitRequest = false;
    asdx::Queue<JobNode>        m_Queue;
    std::mutex                  m_Mutex;
    std::condition_variable     m_Condition;
    std::vector<std::thread>    m_Threads;

    //-------------------------------------------------------------------------
    //! @brief      スレッド処理を実行します.
    //-------------------------------------------------------------------------
    void Worker()
    {
        while(true)
        {
            JobNode* jobNode = nullptr;
            {
                std::unique_lock<std::mutex> locker(m_Mutex);

                while(m_Queue.empty() && !m_ExitRequest)
                { m_Condition.wait(locker); }

                if (m_ExitRequest)
                { return; }

                jobNode = m_Queue.pop();
                assert(jobNode != nullptr);
            }

            jobNode->Run();
        }
    };
};

///////////////////////////////////////////////////////////////////////////////
// JobSyncPoint class
///////////////////////////////////////////////////////////////////////////////
class JobSyncPoint
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    JobSyncPoint() = default;

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~JobSyncPoint()
    {
        auto itr = m_Jobs.begin();
        while(itr != m_Jobs.end())
        {
            auto item = &(*itr);
            itr = m_Jobs.erase(itr);
            if (item)
            {
                delete item;
                item = nullptr;
            }
        }

        m_ReadyCount = 0;
        m_WaitCount  = 0;
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを追加します.
    //-------------------------------------------------------------------------
    void Add(JobNode* job)
    { m_Jobs.push_back(job); }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを削除します.
    //-------------------------------------------------------------------------
    void Remove(JobNode* job)
    { m_Jobs.erase(job); }

    //-------------------------------------------------------------------------
    //! @brief      実行可能状態かどうかチェックします.
    //-------------------------------------------------------------------------
    bool IsReady() const
    { return m_WaitCount == m_ReadyCount; }

    //-------------------------------------------------------------------------
    //! @brief      カウンターをリセットします.
    //-------------------------------------------------------------------------
    void Reset()
    { m_ReadyCount = 0; }

    //-------------------------------------------------------------------------
    //! @brief      前ジョブの完了数をインクリメントします.
    //-------------------------------------------------------------------------
    void IncrementReadyCount()
    { m_ReadyCount++; }

    //-------------------------------------------------------------------------
    //! @brief      ジョブに対応するジョブ情報を探索します.
    //-------------------------------------------------------------------------
    JobNode* Find(const Job& job)
    {
        for(auto itr = m_Jobs.begin(); itr != m_Jobs.end(); ++itr)
        {
            if (itr->Job.StartPoint == job.StartPoint
             && itr->Job.SyncPoint  == job.SyncPoint
             && itr->Job.UserId     == job.UserId
             && itr->Job.pListener  == job.pListener)
            { return &(*itr); }
        }

        return nullptr;
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを含むかどうかチェックします.
    //-------------------------------------------------------------------------
    bool Contain(const Job& job)
    { return Find(job) != nullptr; }

    //-------------------------------------------------------------------------
    //! @brief      ジョブキューに登録します.
    //-------------------------------------------------------------------------
    void PushToJobQueue(JobQueue& queue)
    {
        for(auto& item : m_Jobs)
        { queue.Push(&item); }
    }

    //-------------------------------------------------------------------------
    //! @brief      依存する前ジョブの待機数をインクリメントします.
    //-------------------------------------------------------------------------
    void IncrementWaitCount()
    { ++m_WaitCount; }

    //-------------------------------------------------------------------------
    //! @brief      依存する前のジョブの待機数をデクリメントします.
    //-------------------------------------------------------------------------
    void DecrementWaitCount()
    { --m_WaitCount; }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    List<JobNode>           m_Jobs;
    uint32_t                m_WaitCount  = 0;
    std::atomic<uint32_t>   m_ReadyCount = 0;

    //=========================================================================
    // private methods.
    //=========================================================================
    /* NOTHING */
};

///////////////////////////////////////////////////////////////////////////////
// JobSystem class
///////////////////////////////////////////////////////////////////////////////
class JobSystem : public IJobSystem
{
    //=========================================================================
    // list of friend classes and methods.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    JobSystem() = default;

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~JobSystem() = default;

    //-------------------------------------------------------------------------
    //! @brief      初期化処理です.
    //-------------------------------------------------------------------------
    bool Init(uint32_t syncPointCount, uint8_t threadCount)
    {
        m_SyncPointCount = syncPointCount;
        m_SyncPoints     = new JobSyncPoint[syncPointCount];

        m_JobQueue.Init(threadCount);

        return true;
    }

    //-------------------------------------------------------------------------
    //! @brief      終了処理です.
    //-------------------------------------------------------------------------
    void Term()
    {
        // ジョブキューを破棄.
        m_JobQueue.Term();

        // 同期ポイントを破棄.
        if (m_SyncPoints != nullptr)
        {
            delete [] m_SyncPoints;
            m_SyncPoints = nullptr;
        }

        m_SyncPointCount = 0;

        // 初期化済みフラグを下す.
        m_Initialized = false;
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを追加します.
    //-------------------------------------------------------------------------
    bool Add(const Job& job) override
    {
        assert(job.StartPoint < m_SyncPointCount);
        assert(job.SyncPoint  < m_SyncPointCount);
        assert(job.pListener != nullptr);

        // 2重登録を回避するためにチェック.
        if (m_SyncPoints[job.StartPoint].Contain(job))
        {
            ELOG("Error : ジョブが既に登録済みです.");
            return false;
        }

        auto item = new JobNode();
        item->Job        = job;
        item->pSyncPoint = &m_SyncPoints[job.SyncPoint];

        m_SyncPoints[job.SyncPoint].IncrementWaitCount();
        m_SyncPoints[job.StartPoint].Add(item);

        return true;
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを削除します.
    //-------------------------------------------------------------------------
    bool Remove(const Job& job) override
    {
        assert(job.StartPoint < m_SyncPointCount);
        assert(job.SyncPoint  < m_SyncPointCount);
        assert(job.pListener != nullptr);
    
        auto itr = m_SyncPoints[job.StartPoint].Find(job);
        if (itr == nullptr)
        {
            ELOG("Error : 指定されたジョブが見つからないため, 削除に失敗しました.");
            return false;
        }

        m_SyncPoints[job.SyncPoint].DecrementWaitCount();
        m_SyncPoints[job.StartPoint].Remove(itr);
        delete itr;
        itr = nullptr;

        return true;
    }

    //-------------------------------------------------------------------------
    //! @brief      ジョブを実行します.
    //-------------------------------------------------------------------------
    void Run()
    {
        // リセット処理.
        for(auto i=0u; i<m_SyncPointCount; ++i)
        { m_SyncPoints[i].Reset(); }

        for(auto i=0u; i<m_SyncPointCount; ++i)
        {
            // 実行可能になるまで待機.
            while(!m_SyncPoints[i].IsReady())
            { _mm_pause(); }

            // ジョブキューに詰む.
            m_SyncPoints[i].PushToJobQueue(m_JobQueue);
        }

        // 最後のジョブが終わるまで待機.
        m_JobQueue.Wait();
    }

private:
    //=========================================================================
    // private variables.
    //=========================================================================
    bool            m_Initialized    = false;
    uint32_t        m_SyncPointCount = 0;
    JobSyncPoint*   m_SyncPoints     = nullptr;
    JobQueue        m_JobQueue;

    //=========================================================================
    // private methods.
    //=========================================================================
};

//-----------------------------------------------------------------------------
//      ジョブを実行します.
//-----------------------------------------------------------------------------
void JobNode::Run()
{
    // ジョブを実行.
    Job.pListener->OnRun(Job.UserId);

    // 同期ポイントに通知.
    pSyncPoint->IncrementReadyCount();
}

//-----------------------------------------------------------------------------
//      ジョブシステムの初期化処理.
//-----------------------------------------------------------------------------
bool InitJobSystem(uint32_t syncPointCount, uint8_t threadCount)
{
    if (g_JobSystem != nullptr)
    { return false; }

    g_JobSystem = new JobSystem();
    g_JobSystem->Init(syncPointCount, threadCount);

    return true;
}

//-----------------------------------------------------------------------------
//      ジョブシステムの終了処理.
//-----------------------------------------------------------------------------
void TermJobSystem()
{
    if (g_JobSystem == nullptr)
    { return; }

    g_JobSystem->Term();

    delete g_JobSystem;
    g_JobSystem = nullptr;
}

//-----------------------------------------------------------------------------
//      ジョブシステムを取得します.
//-----------------------------------------------------------------------------
IJobSystem* GetJobSystem()
{ return g_JobSystem; }

} // namespace asdx

